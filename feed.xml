<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BugCoder - Articles</title>
    <description>没啥说的，就是干</description>
    <link>
    </link>
    
      
      <item>
        <title>负载均衡实现方式</title>
        
          <description>&lt;h2 id=&quot;一负载均衡的基本概念&quot;&gt;一、负载均衡的基本概念&lt;/h2&gt;

&lt;p&gt;负载均衡是指，将请求分发到 多台 应用服务器，以此来分散 压力的一种架构方式，他是以集群的方式存在，并且当 某个节点挂掉的时候，可以自动 不再将请求分配到此节点。&lt;/p&gt;

&lt;h2 id=&quot;二-实现方式&quot;&gt;二、 实现方式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;重定向&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种方式，是通过将请求全部发送到前置机，由前置机通过算法 得出要分配给那台 应用服务器，然后响应给客户端，由客户端重定向到应用服务器的一种方式。&lt;/p&gt;

&lt;p&gt;这种方式，由于每一个的请求，都要重定向一下，所以效率不是很高&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;反向代理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种方式，是通过在前置机，使用反向代理的方式，将请求分发到应用服务器，客户端无需再请求一次，实现方式通常有两种，一种是用交换机实现，还有一种是用nginx这一类的软件实现&lt;/p&gt;

&lt;p&gt;这种方式，由于不需要再次重定向，所以较第一种，效率较高，但是由于请求和响应都是通过前置机来的，所以对前置机的考验很大&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据链路返回&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这种方式，通过给应用服务器设置虚拟IP，然后通过修改mac地址的方式，将请求分发出去，而应用服务器 收到请求后，可以直接响应给客户端，而不需要经过前置机。&lt;/p&gt;

&lt;p&gt;这种方式，由于 前置机 只需要接受请求，不需要响应数据，所以，效率较第二种较高。&lt;/p&gt;

&lt;h2 id=&quot;三-负载均衡算法&quot;&gt;三、 负载均衡算法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;轮询法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将请求按顺序轮流地分配到后端服务器上，它均衡地对待后端的每一台服务器，而不关心服务器实际的连接数和当前的系统负载。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;随机法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过系统的随机算法，根据后端服务器的列表大小值来随机选取其中的一台服务器进行访问。由概率统计理论可以得知，随着客户端调用服务端的次数增多，&lt;/p&gt;

&lt;p&gt;其实际效果越来越接近于平均分配调用量到后端的每一台服务器，也就是轮询的结果。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;源地址哈希法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;源地址哈希的思想是根据获取客户端的IP地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一IP地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加权轮询法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，让其处理更多的请；而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;加权随机法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与加权轮询法一样，加权随机法也根据后端机器的配置，系统的负载分配不同的权重。不同的是，它是按照权重随机请求后端服务器，而非顺序。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最小连接数法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前 积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器。&lt;/p&gt;
</description>
        
        <pubDate>Sun, 21 Aug 2016 13:32:00 +0000</pubDate>
        <link>
        /balancing-1</link>
        <guid isPermaLink="true">/balancing-1</guid>
      </item>
      
    
      
      <item>
        <title>设计模式-单例模式</title>
        
          <description>&lt;p&gt;###创建型模式-单例模式&lt;/p&gt;

&lt;p&gt;为实现类的唯一性，我们需要通过如下三个步骤对该类进行重构：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;为了确保实例的唯一性，我们需要禁止类的外部直接使用new来创建对象，因此需要将类的构造函数的可见性改为private，如下所示：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Singleton(){}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;虽然类的外部无法使用new来创建对象，但是在Singleton的内部还是可以创建的，可见性只对类外有效。因此，我们可以在Singleton中创建并保存这个唯一实例。为了让外界可以访问这个唯一实例，需要在Singleton中定义一个静态的Singleton类型的私有成员变量，如下所示：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static Singleton singleton = null;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了保证成员变量的封装性，我们将Singleton类型的singleton对象的可见性设置为private，但是外界该如何使用该成员变量并何时实例化该成员变量呢？那就是增加一个公有的静态方法，如下所示&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Singleton getInstance(){
    if(null == singleton){
        singleton = new Singleton();
    }
    return singleton;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。&lt;/p&gt;

&lt;p&gt;上述单例模式在多线程下也会出现获取实例不相同的情况，究其原因，当第一次调用getInstance()方法时，，金探测对象为null，因此系统将执行代码instance = new Singleton()，在此过程中，由于要对Singleton进行大量初始化工作，需要一段使劲来创建Singleton对象。而在此时，如果再一次调用getinstance()方法，由于instance尚未创建成功，仍为null，因此instance = new Singelton()将再次执行，导致最终创建了多个instance对象。&lt;/p&gt;

&lt;p&gt;有两种方案可以解决上述问题，饿汉模式和懒汉模式&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;饿汉模式&lt;/strong&gt;直接上代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;饿汉模式
class Singleton{
    private static final Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return intance;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多线程模式下，饿汉模式不会出现创建多个单例对象的情况，可以确保单例对象的唯一性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;懒汉模式&lt;/strong&gt;直接上代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Singleton{
    private static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance(){
        if(null == instance){
            synchronized(Singleton.class){
                instance = new Singleton();
            }
        }
        return instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;多线程情况下，上述懒汉模式还是会出现单例对象不唯一的情况，加入线程A进入synchronized锁定代码，线程B处于排队等待状态。但是当A执行完毕时，线程B并不知道实例已经创建，线程B继续创建实例，会导致产生多个单例对象。进一步改进，在synchronized中再进行一次判断，这种方式称为双重检查锁定(Double-Check Locking)。代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Singleton{
    private volatile static Singleton instance = null;
    private Singleton(){}
    public static Singleton getInstance(){
        if(null == instance){
            synchronized(Singleton.class){
                if(null == instance){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;需要注意的是，如果使用双重检查锁定来实现懒汉模式，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低。&lt;/p&gt;

&lt;p&gt;可以从资源利用效率和资源初始化耗时两方面比较饿汉模式和懒汉模式的优劣。&lt;/p&gt;

&lt;p&gt;有没有一种方式，可以克服两种模式的缺点呢，是的，有！&lt;/p&gt;

&lt;p&gt;Initialization Demand Holder（IoDH），在IoDH中，我们在单例类中增加一个静态（static）内部类，在该类内部创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Singleton{
    private Singleton(){}
    private static class HolderClass{
        private final static Singleton instance = new Singleton();
    }
    public static Singleton getInstance(){
        return HolderClass.instance;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过使用IoDH，既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种好的单例模式实现方式，其缺点是与编程语言本身的特性相关，很多面向对象的语言不支持IoDH。&lt;/p&gt;
</description>
        
        <pubDate>Tue, 21 Jun 2016 11:18:00 +0000</pubDate>
        <link>
        /design-singleton</link>
        <guid isPermaLink="true">/design-singleton</guid>
      </item>
      
    
      
      <item>
        <title>Spring 传播机制实战</title>
        
          <description>&lt;p&gt;&amp;amp;nbsp&lt;/p&gt;
&lt;h3 id=&quot;场景佩奇要给乔治转账&quot;&gt;场景：佩奇要给乔治转账&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;基础操作：扣钱和加钱&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * 取款操作
     * @param name 用户
     * @param usd 钱
     */
	void withdrawal(String name, BigDecimal usd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * 存款操作
     * @param name 用户
     * @param usd 钱
     */
    void deposit(String name, BigDecimal usd);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;业务操作：转账，pappe给george转账10000块&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	/**
     * 转账服务
     * @param oName 从该用户扣钱
     * @param dName 向该用户加钱
     */
    void transfer(String oName, String dName){
        balanceService.withdrawal(oName,new BigDecimal(10000));
        balanceService.deposit(dName,new BigDecimal(10000));
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;##别说话，就是干&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;propagation_required&lt;/p&gt;

    &lt;p&gt;Spring默认的事务传播机制，如果外层有事务则该事物加入外层事务，一起提交或回滚，如果没有事务则当前开启一个新事物，该机制满足大多数业务场景。&lt;/p&gt;

    &lt;p&gt;transfer、withdrawal、deposit传播机制都设置为&lt;strong&gt;propagation_required&lt;/strong&gt;，任何一个方法抛异常，整个事务都会回滚。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        
        <pubDate>Sun, 27 Sep 2015 10:18:00 +0000</pubDate>
        <link>
        /spring-propagation</link>
        <guid isPermaLink="true">/spring-propagation</guid>
      </item>
      
    
      
      <item>
        <title>位运算</title>
        
          <description>&lt;h2 id=&quot;1技巧一&quot;&gt;1.&lt;strong&gt;技巧一&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x &amp;amp; (x - 1) 用于消去x最后一位的1
x = 1100
x - 1 = 1011
x &amp;amp; (x - 1) = 1000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.1.应用一&lt;/strong&gt; &lt;strong&gt;用 O(1) 时间检测整数 n 是否是 2 的幂次。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.lintcode.com/zh-cn/problem/o1-check-power-of-2/&quot;&gt;http://www.lintcode.com/zh-cn/problem/o1-check-power-of-2/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;思路解析：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;N如果是2的幂次，则N满足两个条件。
  1.N &amp;gt;0 
  2.N的二进制表示中只有一个1
因为N的二进制表示中只有一个1，所以使用N &amp;amp; (N - 1)将N唯一的一个1消去，应该返回0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2.应用二&lt;/strong&gt; &lt;strong&gt;计算在一个 32 位的整数的二进制表式中有多少个 1。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.lintcode.com/zh-cn/problem/count-1-in-binary/&quot;&gt;http://www.lintcode.com/zh-cn/problem/count-1-in-binary/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;思路解析：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;由x &amp;amp; (x - 1)消去x最后一位的1可知。不断使用 x &amp;amp; (x - 1) 消去x最后一位的1，计算总共消去了多少次即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.3.应用三&lt;/strong&gt; &lt;strong&gt;如果要将整数A转换为B，需要改变多少个bit位？&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.lintcode.com/zh-cn/problem/flip-bits/&quot;&gt;http://www.lintcode.com/zh-cn/problem/flip-bits/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个应用是上面一个应用的拓展。
思考将整数A转换为B，如果A和B在第i（0&amp;lt;=i&amp;lt;32）个位上相等，则不需要改变这个BIT位，如果在第i位上不相等，则需要改变这个BIT位。所以问题转化为了A和B有多少个BIT位不相同。联想到位运算有一个异或操作，相同为0，相异为1，所以问题转变成了计算A异或B之后这个数中1的个数。&lt;/p&gt;

&lt;h2 id=&quot;2技巧二&quot;&gt;2&lt;strong&gt;技巧二&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用二进制进行子集枚举
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;应用&lt;/strong&gt; &lt;strong&gt;给定一个含不同整数的集合，返回其所有的子集。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.lintcode.com/zh-cn/problem/subsets/&quot;&gt;http://www.lintcode.com/zh-cn/problem/subsets/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;思路就是使用一个正整数二进制表示的第i位是1还是0，代表集合的第i个数取或者不取。
所以从0到2^n-1总共2^n个整数，正好对应集合的2^n个子集。&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;S = {1,2,3}
N bit Combination
0 000 {}
1 001 {1}
2 010 {2}
3 011 {1,2}
4 100 {3}
5 101 {1,3}
6 110 {2,3}
7 111 {1,2,3}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;3技巧三&quot;&gt;3&lt;strong&gt;技巧三&lt;/strong&gt;&lt;/h2&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a ^ b ^ b = a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.1.应用一&lt;/strong&gt; &lt;strong&gt;数组中，只有一个数出现一次，剩下都出现两次，找出出现一次的数&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.lintcode.com/en/problem/single-number/&quot;&gt;http://www.lintcode.com/en/problem/single-number/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;思路解析：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为只有一个数恰好出现一个，剩下的都出现过两次，所以只要将所有的数异或起来，就可以得到唯一的那个数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.2.应用二&lt;/strong&gt; &lt;strong&gt;数组中，只有一个数出现一次，剩下都出现三次，找出出现一次的。&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.lintcode.com/en/problem/single-number-iii/&quot;&gt;http://www.lintcode.com/en/problem/single-number-iii/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;解题思路：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为数是出现三次的，也就是说，对于每一个二进制位，如果只出现一次的数在该二进制位为1，那么这个二进制位在全部数字中出现次数无法被3整除。
膜3运算只有三种状态：00,01,10，因此我们可以使用两个位来表示当前位%3，对于每一位，我们让Two，One表示当前位的状态，B表示输入数字的对应位，Two+和One+表示输出状态。&lt;/p&gt;

&lt;div class=&quot;language-text highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0 0 0 0 0
 0 0 1 0 1
 0 1 0 0 1
 0 1 1 1 0
 1 0 0 1 0
 1 0 1 0 0
 One+ = (One ^ B) &amp;amp; (~Two)
 Two+ = (~One+) &amp;amp; (Two ^ B)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.3.应用三&lt;/strong&gt; &lt;strong&gt;数组中，只有两个数出现一次，剩下都出现两次，找出出现一次的&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//www.lintcode.com/en/problem/single-number-iii/&quot;&gt;http://www.lintcode.com/en/problem/single-number-iii/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;思路解析：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有了第一题的基本的思路，我们可以将数组分成两个部分，每个部分里只有一个元素出现一次，其余元素都出现两次。那么使用这种方法就可以找出这两个元素了。
不妨假设出现一个的两个元素是x，y，那么最终所有的元素异或的结果就是res  =  x^y。并且res！=0，那么我们可以找出res二进制表示中的某一位是1。对于原来的数组，我们可以根据这个位置是不是1就可以将数组分成两个部分。x，y在不同的两个子数组中。而且对于其他成对出现的元素，要么在x所在的那个数组，要么在y所在的那个数组。&lt;/p&gt;
</description>
        
        <pubDate>Sun, 27 Sep 2015 10:18:00 +0000</pubDate>
        <link>
        /bit-operation</link>
        <guid isPermaLink="true">/bit-operation</guid>
      </item>
      
    
  </channel>
</rss>
